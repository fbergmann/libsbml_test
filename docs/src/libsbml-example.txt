/** @page libsbml-example Tutorial: Creating a complete model, from start to finish

This section presents a complete example program in C++ demonstrating
how to create a complete SBML model programmatically and then writing
the result to a file.  

@section characteristics General characteristics of the model to be created

The model presented here is the one described in Section&nbsp;7.1 of
the <a target="_blank"
href="http://sbml.org/Documents/Specifications">SBML Level&nbsp;2
Version&nbsp;4 specification</a>.  It consists of four species
identified simply as <em>E</em>, <em>S</em>, <em>ES</em>, and
<em>P</em>; one compartment identified as <em>cytosol</em>; and two
reactions (one reversible, one irreversible) described by the
following equation:

@image html enzymatic-reaction.jpg
@image latex enzymatic-reaction.jpg

From these equations, it becomes clear that the model also contains
three parameters: <em>k<sub>on</sub></em>, <em>k<sub>off</sub></em>,
and <em>k<sub>cat</sub></em>.

We will need to assign initial values to these parameters, as well as
to the size of the compartment and the initial quantities of the
species.  Since this model is only meant to illustrate the principles
of programming with libSBML, and does not represent an actual
biological entity, we hope readers will forgive us for not worrying
about justifying the parameter values on the basis of biological
plausibility.  The table of values for all the quantities we will use
is shown below:

<center>
<table border="0" class="text-table width80 normal-font alt-row-colors">
 <tr style="background: lightgray; font-size: 14px;">
     <th align="left">Entity in the %Model</th>
     <th align="left">Initial value</th>
     <th align="left">Units</th>
 </tr>
<tr><td><em>cytosol</em></td><td>\f$1 \times 10^{-14}\f$</td><td>litres</td></tr>
<tr><td><em>S</em></td><td>\f$1 \times 10^{-20}\f$</td><td>moles</td></tr>
<tr><td><em>P</em></td><td>0</td><td>moles</td></tr>
<tr><td><em>E</em></td><td>\f$5 \times 10^{-21}\f$</td><td>moles</td></tr>
<tr><td><em>ES</em></td><td>0</td><td></td>moles</tr>
<tr><td><em>k<sub>on</sub></em></td><td>1 000 000</td><td>litre/mole/second</td></tr>
<tr><td><em>k<sub>off</sub></em></td><td>0.2</td><td>1/second</td></tr>
<tr><td><em>k<sub>cat</sub></em></td><td></td><td>1/second</td></tr>
</table>
</center>

For variety, we will use substance units instead of concentration
units for the initial values of the species.  This is reflected in the
use of moles instead of moles/litre as the species quantity units in
the table above.


@section code The program for creating the model

To begin, our program has to include certain header files needed by
libSBML under C++.  For convenience, we will also set the default C++
namespace to <code>std</code> so that we do not have to prefix common
C++ functions used throughout our code.

@verbatim
/**
 * File:        example.cpp
 * Description: Create an example model.
 * Author:      Akiya Jouraku
 */

#include <iostream>
#include <sbml/SBMLTypes.h>

using namespace std;
@endverbatim


The next few lines of our program will not be used until the end of
the program, but the relevant definitions are best put near the
beginning as a principle of good programming.  Specifically, this is
the definition of a program name and version number, to be inserted by
libSBML as XML comments into the final SBML file.  We will do
something very simple here and define the relevant values as global
parameters; other approaches are possible.

@verbatim
//
// These variables are used in writeExampleSBML when writing an SBML
// document.  They are handed to libSBML functions in order to include
// the program information into comments within the SBML file.
//
const static string ProgramName    = "createExample";
const static string ProgramVersion = "1.0.0";
@endverbatim


We need a few forward declarations for helper functions.  Here they
are:

@verbatim
//
// Forward declarations for functions defined below.
//
SBMLDocument* createExampleEnzymaticReaction();
bool validateExampleSBML(SBMLDocument *sbmlDoc);
bool writeExampleSBML(const SBMLDocument *sbmlDoc, const string& filename);
@endverbatim


Now we can define a main routine for the program.  This essentially acts as
scaffolding for calling worker functions and dealing with overall errors.

@verbatim
//
// Main routine
//
int
main (int argc, char *argv[])
{
  SBMLDocument* sbmlDoc = 0;
  bool SBMLok           = false;

  try
  {
    sbmlDoc = createExampleEnzymaticReaction(); 
    SBMLok  = validateExampleSBML(sbmlDoc);
    if (SBMLok) writeExampleSBML(sbmlDoc, "enzymaticreaction.xml");

    // Avoid memory leaks.
    delete sbmlDoc;

    // Return non-zero to indicate if a problem occurred.
    if (!SBMLok) return 1;
  }
  catch (std::bad_alloc& e)
  {
    cerr << e.what() << ": Unable to allocate memory." << endl;
    return 1;
  }
  catch (...)
  {
    cerr << "Unexpected exceptional condition encountered." << endl;
    return 1;
  }

  // A 0 return status is the standard Unix/Linux way to say "all ok".
  return 0;
}
@endverbatim

The code above has three key functions,
<code>createExampleEnzymaticReaction()</code>,
<code>validateExampleSBML</code>, and <code>writeExampleSBML()</code>,
which do all the real work in the program.  Their verbose names hopefully
imply their functions.  They are described and defined in the next three
subsections.


@subsection creator Function for creating the model

We begin this function by creating an SBMLDocument object, creating a
Model object within the document object, and setting the Model
object's identifier.

@verbatim
/**
 * Create an SBML model represented in "7.1 A Simple example application
 * of SBML" in the SBML Level 2 Version 4 Specification.
 */
SBMLDocument* createExampleEnzymaticReaction()
{
  // Create an SBMLDocument object using in Level 2 Version 4 format:

  SBMLDocument* sbmlDoc = new SBMLDocument(2, 4);

  // Create a Model object inside the SBMLDocument object and sets
  // its identifier:

  Model* model = sbmlDoc->createModel();
  model->setId("EnzymaticReaction");
@endverbatim


Next, we need to define some units in order to properly characterize
the quantities used in the model.  The libSBML API for unit
definitions mirrors the SBML object model, which means there is an
object class for UnitDefinition and an object class for the Unit
objects that can be placed inside a UnitDefinition object to compose
whatever unit is desired.  The resulting code for creating units is a
little bit tedious because there is a lot to set up, but on the other
hand, it is quite straightforward and hopefully easy to follow:

@verbatim
  // Temporary pointers (reused more than once below).

  UnitDefinition* unitdef;
  Unit* unit;

  // (UnitDefinition1) Create an UnitDefinition object for "per_second".

  unitdef = model->createUnitDefinition();
  unitdef->setId("per_second");

  // Create an Unit inside the UnitDefinition object above:

  unit = unitdef->createUnit();
  unit->setKind(UNIT_KIND_SECOND);
  unit->setExponent(-1);

  // (UnitDefinition2) Create an UnitDefinition object for
  // "litre_per_mole_per_second".  Note that we can reuse the pointers
  // 'unitdef' and 'unit' because the actual UnitDefinition object
  // (along with the Unit objects within it) is already attached to
  // the Model object. (Refer to the first two lines above.)
    
  unitdef = model->createUnitDefinition();
  unitdef->setId("litre_per_mole_per_second");
    
  // Create individual unit objects that will be put inside
  // the UnitDefinition to compose "litre_per_mole_per_second".

  unit = unitdef->createUnit();
  unit->setKind(UNIT_KIND_MOLE);
  unit->setExponent(-1);

  unit = unitdef->createUnit();
  unit->setKind(UNIT_KIND_LITRE);
  unit->setExponent(1);

  unit = unitdef->createUnit();
  unit->setKind(UNIT_KIND_SECOND);
  unit->setExponent(-1);
@endverbatim


Next, we create a compartment object.

@verbatim
  // Creat a string for the identifier of the compartment.  This
  // will be used again later, so it's worth defining a constant here.

  const string compName = "cytosol";

  // Create a Compartment object ("cytosol")

  Compartment* comp = model->createCompartment();
  comp->setId(compName);
 
  // Set the "size" attribute of the Compartment object.  We are not
  // setting the units on the compartment size explicitly, so the units
  // of this Compartment object will be the default SBML units of volume,
  // which are liters.

  comp->setSize(1e-14);
@endverbatim


Onward now to the species definitions in the model.  For each species,
the program needs to set an identifier, the compartment in which it's
located, and optionally the initial quantity of the species in the
compartment.

@verbatim
  // Temporary pointer (reused more than once below).
  
  Species *sp;

  // Create the Species objects inside the Model object. 

  // (Species1) Create a Species object for species "ES", and set its
  // compartment attribute to be the "cytosol" compartment in the model.

  sp = model->createSpecies();
  sp->setCompartment(compName);
  sp->setId("ES");

  // Set the "initialAmount" attribute of the Species object.
  //
  //  In SBML, the units of a Species object's initial quantity are
  //  determined by two attributes, "substanceUnits" and
  //  "hasOnlySubstanceUnits", and the "spatialDimensions" attribute
  //  of the Compartment object ("cytosol") in which the species
  //  object is located.  Here, we are using the default values for
  //  "substanceUnits" (which is "mole") and "hasOnlySubstanceUnits"
  //  (which is "false").  The compartment in which the species is
  //  located uses volume units of liters, so the units of these
  //  species (when the species appear in numerical formulas in the
  //  model) will be moles/liter.  
  //
  sp->setInitialAmount(0);

  // (Species2) Create a Species object for "P"

  sp = model->createSpecies();
  sp->setCompartment(compName);
  sp->setId("P");
  sp->setInitialAmount(0);

  // (Species3) Create a Species object for "S"

  sp = model->createSpecies();
  sp->setCompartment(compName);
  sp->setId("S");
  sp->setInitialAmount(1e-20);

  // (Species4) Create a Species object for "E"

  sp = model->createSpecies();
  sp->setCompartment(compName);
  sp->setId("E");
  sp->setInitialAmount(5e-21);
@endverbatim


It remains only to create objects representing the reactions in the
model.  In this example, we will create the system as one reversible
and one irreversible reaction; alternatively, the system could have
been created as three irreversible reactions.

@verbatim
  // Temporary pointers reused below.

  Reaction* reaction;
  SpeciesReference* spr;
  Parameter* para;
  KineticLaw* kl;

  // Create Reactant objects inside the Reaction object ("veq"). 

  reaction = model->createReaction();
  reaction->setId("veq");

  // (Reactant1) Create a Reactant object that references Species "E"
  // in the model.  The object will be created within the reaction in the
  // SBML <listOfReactants>.

  spr = reaction->createReactant();
  spr->setSpecies("E");

  // (Reactant2) Create a Reactant object that references Species "S"
  // in the model.

  spr = reaction->createReactant();
  spr->setSpecies("S");

  // Create a Product object that references Species "ES" in the model. 

  spr = reaction->createProduct();
  spr->setSpecies("ES");

  // Create a KineticLaw object inside the Reaction object ("veq").
  // To create mathematical expressions, one would typically construct
  // an ASTNode tree.  Here, to save some space and illustrate another
  // approach of doing it, we will write out the formula in MathML
  // form and then use a libSBML convenience function to create the
  // ASTNode tree for us.  (This is a bit dangerous; it's very easy to
  // make mistakes when writing MathML by hand, so in a real program,
  // we would not really want to do it this way.)
  
  kl  = reaction->createKineticLaw();

  // In the MathML below, note how the formula includes the volume of
  // the compartment "cytosol".  The reason for this volume correction
  // factor is explained in detail in the SBML specification document,
  // and follows from the fact that SBML "kinetic laws" must yield
  // substance/time units, not concentration/time units.

  string mathXMLString = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"
                         "  <apply>"
                         "    <times/>"
                         "    <ci> cytosol </ci>"
                         "    <apply>"
                         "      <minus/>"
                         "      <apply>"
                         "        <times/>"
                         "        <ci> kon </ci>"
                         "        <ci> E </ci>"
                         "        <ci> S </ci>"
                         "      </apply>"
                         "      <apply>"
                         "        <times/>"
                         "          <ci> koff </ci>"
                         "          <ci> ES </ci>"
                         "      </apply>"
                         "    </apply>"
                         "  </apply>"
                         "</math>";

  kl->setMath(readMathMLFromString(mathXMLString.c_str()));

  // Create local Parameter objects for "kon" and "koff" inside the
  // KineticLaw object.  Note how we set the units on the parameter
  // values.

  para = kl->createParameter();
  para->setId("kon");
  para->setValue(1000000);
  para->setUnits("litre_per_mole_per_second");

  para = kl->createParameter();
  para->setId("koff");
  para->setValue(0.2);
  para->setUnits("per_second");
@endverbatim


That was one reaction.  One more reaction to go.  It follows the above
pattern.

@verbatim
  // (Reaction2) Create a Reaction object ("vcat") .
  
  reac = model->createReaction();
  reac->setId("vcat");
  reac->setReversible(false);

  // Create Reactant objects inside the Reaction object ("vcat"). 

  // (Reactant1) Create a Reactant object that references Species
  // "ES" in the model.

  spr = reac->createReactant();
  spr->setSpecies("ES");

  // (Product1) Create a Product object that references Species "E"
  // in the model.
  
  spr = reac->createProduct();
  spr->setSpecies("E");

  // (Product2) Create a Product object that references Species "P"
  // in the model.

  spr = reac->createProduct();
  spr->setSpecies("P");

  // Create a KineticLaw object inside the Reaction object ("vcat"). 
  
  kl = reac->createKineticLaw();

  // Set the math (ASTNode object) to the KineticLaw object.  As in
  // the case of the first reaction ("veq") earlier, we define the
  // formula in MathML and then convert it to ASTNode.

  mathXMLString = "<math xmlns=\"http://www.w3.org/1998/Math/MathML\">"
                  "  <apply>"
                  "    <times/>"
                  "    <ci> cytosol </ci>"
                  "    <ci> kcat </ci>"
                  "    <ci> ES </ci>"
                  "  </apply>"
                  "</math>";

  kl->setMath(readMathMLFromString(mathXMLString.c_str()));

  // Create a local Parameter object for "kcat" inside the KineticLaw
  // object.

  para = kl->createParameter();
  para->setId("kcat");
  para->setValue(0.1);
  para->setUnits("per_second");
@endverbatim


That concludes all the model creation code.  Our
<code>createExampleEnzymaticReaction()</code> function now only needs
to return the SBMLDocument object that it created.

@verbatim
  // Return the created SBMLDocument object.
  // The returned object must be explicitly deleted by the caller,
  // otherwise a memory leak will happen.

  return sbmlDoc;
}
@endverbatim


@subsection validating Function for verifying the model

One of the most important features of libSBML is its ability to
perform SBML validation to ensure that a model adheres to the SBML
specification for whatever Level+Version combination the model uses.
Although the example program presented here is short and we can verify
its correctness by inspection, in more general programs, it is
difficult to ensure that everything in a model is constructed
properly.  The ability to perform automatic checks then becomes very
useful.  We therefore take this opportunity to illustrate the use of
libSBML's validation and checking facilities.

The rationale behind libSBML's consistency-checking and validation
functions is the following.  In libSBML versions up to and including
the version 3.3.x series, the individual methods for creating and
setting attributes and other components are quite lenient, and allow a
caller to compose SBML entities that may not, in the end, represent
valid SBML.  This allows applications the freedom to do things such as
save incomplete models (which is useful when models are being
developed over long periods of time), but at the same time, it means
that a separate validation step is necessary when a calling program
finally wants to finish a complete SBML document.

LibSBML implements verification of SBML in two steps, represented by
the two methods SBMLDocument::checkInternalConsistency() and
SBMLDocument::checkConsistency().  The former verifies the basic
internal consistency and syntax of an SBML document, and the latter
implements more elaborate validation rules (both those defined by the
SBML specifications, as well as additional rules offered by libSBML).
When an application builds up a model programmatically and is finally
ready to say "yes, this model is finished", it should call both of
these methods to help ensure the correctness and consistency of the
finished result.  Conversely, if it is reading a model from a file or
data stream, libSBML will automatically run
SBMLDocument::checkInternalConsistency().  The application only needs
to check the results by interrogating the error log on the
SBMLDocument object, then call SBMLDocument::checkConsistency() for
checking the model against the SBML validation rules.

The following code illustrates a complete sequence of checking a
newly-created model using both
SBMLDocument::checkInternalConsistency() and
SBMLDocument::checkConsistency(), and handling the reporting of
problems to the user.

@verbatim
bool validateExampleSBML (SBMLDocument* sbmlDoc)
{
  if (!sbmlDoc)
  {
    cerr << "validateExampleSBML: given a null SBML Document" << endl;
    return false;
  }
 
  string consistencyMessages;
  string validationMessages;
  bool noProblems                  = true;
  unsigned int numCheckFailures       = 0;
  unsigned int numConsistencyErrors   = 0;
  unsigned int numConsistencyWarnings = 0;
  unsigned int numValidationErrors    = 0;
  unsigned int numValidationWarnings  = 0;

  // LibSBML 3.3 is lenient when generating models from scratch using the
  // API for creating objects.  Once the whole model is done and before it
  // gets written out, it's important to check that the whole model is in
  // fact complete, consistent and valid.

  numCheckFailures = sbmlDoc->checkInternalConsistency();
  if ( numCheckFailures > 0 )
  {
    noProblems = false;
    for (unsigned int i = 0; i < numCheckFailures; i++)
    {
      const SBMLError* sbmlErr = sbmlDoc->getError(i);
      if ( sbmlErr->isFatal() || sbmlErr->isError() )
      {
        ++numConsistencyErrors;
      }
      else
      {
        ++numConsistencyWarnings;
      }      
    } 
    ostringstream oss;
    sbmlDoc->printErrors(oss);
    consistencyMessages = oss.str(); 
  }

  // If the internal checks fail, it makes little sense to attempt
  // further validation, because the model may be too compromised to
  // be properly interpreted.

  if (numConsistencyErrors > 0)
  {
    consistencyMessages += "Further validation aborted."; 
  }
  else
  {
    numCheckFailures = sbmlDoc->checkConsistency();
    if ( numCheckFailures > 0 )
    {
      noProblems = false;
      for (unsigned int i = 0; i < numCheckFailures; i++)
      {
        const SBMLError* sbmlErr = sbmlDoc->getError(i);
        if ( sbmlErr->isFatal() || sbmlErr->isError() )
        {
          ++numValidationErrors;
        }
        else
        {
          ++numValidationWarnings;
        }      
      } 
      ostringstream oss;
      sbmlDoc->printErrors(oss);
      validationMessages = oss.str(); 
    }
  }

  if (noProblems)
    return true;
  else
  {
    if (numConsistencyErrors > 0)
    {
      cout << "ERROR: encountered " << numConsistencyErrors 
           << " consistency error" << (numConsistencyErrors == 1 ? "" : "s")
	   << " in model '" << sbmlDoc->getModel()->getId() << "'." << endl;
    }
    if (numConsistencyWarnings > 0)
    {
      cout << "Notice: encountered " << numConsistencyWarnings
           << " consistency warning" << (numConsistencyWarnings == 1 ? "" : "s")
	   << " in model '" << sbmlDoc->getModel()->getId() << "'." << endl;
    }
    cout << endl << consistencyMessages;

    if (numValidationErrors > 0)
    {
      cout << "ERROR: encountered " << numValidationErrors
           << " validation error" << (numValidationErrors == 1 ? "" : "s")
	   << " in model '" << sbmlDoc->getModel()->getId() << "'." << endl;
    }
    if (numValidationWarnings > 0)
    {
      cout << "Notice: encountered " << numValidationWarnings
           << " validation warning" << (numValidationWarnings == 1 ? "" : "s")
	   << " in model '" << sbmlDoc->getModel()->getId() << "'." << endl;
    }
    cout << endl << validationMessages;

    return (numConsistencyErrors == 0 && numValidationErrors == 0);
  }
}
@endverbatim





@subsection writing Function for writing the model

The final step of writing out a model is relatively trivial.  LibSBML
provides a class of object (SBMLWriter) that provides the necessary
functionality.  All that is left to do is to call it with a desired file
name.

@verbatim
/**
 *
 * Writes the given SBMLDocument to the given file.
 *
 */ 
bool writeExampleSBML(const SBMLDocument* sbmlDoc, const string& filename)
{
  SBMLWriter sbmlWriter;

  bool result = sbmlWriter.writeSBML(sbmlDoc, filename);

  if (result)
  {
    cout << "Wrote file \"" << filename << "\"" << endl;
    return true;
  }
  else
  {
    cerr << "Failed to write \"" << filename << "\"" << endl;
    return false;
  }
}
@endverbatim


@section source Source code

An expanded version of this example is supplied with the libSBML
distribution as the file named <code>createExampleSBML.cpp</code> in
the directory <code>examples/c++</code>.




*/
<!-- The following is for [X]Emacs users.  Please leave in place. -->
<!-- Local Variables: -->
<!-- fill-column: 70 -->
<!-- End: -->
